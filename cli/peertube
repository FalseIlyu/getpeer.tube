#!/usr/bin/sh

# Docker Compose binary path
COMPOSE=/usr/local/bin/docker-compose

# Peertube: https raw url of docker production PeerTube setup
PEERTUBE_DOCKER_RAW_URL=https://raw.githubusercontent.com/kimsible/getpeer.tube/master

# PeerTube Working directory
WORKDIR=/var/peertube

# Colors
ORANGE='\033[0;33m'
GREEN='\033[0;32m'
RED='\033[0;31m'
NC='\033[0m' # No Color

# Response Type
ERROR=${RED}ERROR${NC}
DONE=${GREEN}done${NC}

# SERVER_TOOLS LIST
SERVER_TOOLS="
parse-log
create-transcoding-job
create-import-video-file-job
prune-storage
regenerate-thumbnails
optimize-old-videos
update-host
reset-password
plugin:install
plugin:uninstall
purge-old-account
psql
postgres:down
postgres:dump
postgres:restore
postgres:up
up
down
upgrade
show-dkim
show-admin
generate-ssl-certificate
"

# Limit command to Server Tools List
if [ -z $1 ] || [ -z "`echo $SERVER_TOOLS | grep -o -w $1`" ]; then
  echo "\nUsage:	peertube SERVER_TOOL\n"
  echo "Server Tools:\n$SERVER_TOOLS"
  exit 1
fi

# Go to workir
cd $WORKDIR

missing_prerequisites=0

if [ ! -f .env ]; then
  echo "$ERROR: Docker-compose ENV VARS `$WORKDIR/docker-volume/.env` not found, can't run `peertube $1`."
fi

if [ ! -f docker-compose.yml ]; then
  echo "$ERROR: Docker-compose file `$WORKDIR/docker-volume/docker-compose.yml` not found, can't run `peertube $1`."
fi

# Exit if not all prerequisites
if [ "$missing_prerequisites" -ne 0 ]; then exit 1; fi

# Get postgres user
POSTGRES_USER="`grep -E -o "^POSTGRES_USER=(.+)" .env | sed -E "s/POSTGRES_USER=//g"`"

# Get postgres db
POSTGRES_DB="`grep -E -o "^POSTGRES_DB=(.+)" .env | sed -E "s/POSTGRES_DB=//g"`"

# Get postgres service name
PEERTUBE_DB_HOSTNAME="`grep -E -o "^PEERTUBE_DB_HOSTNAME=(.+)" .env | sed -E "s/PEERTUBE_DB_HOSTNAME=//g"`"

# Get webserver hostname
PEERTUBE_WEBSERVER_HOSTNAME="`grep -E -o "^PEERTUBE_WEBSERVER_HOSTNAME=(.+)" .env | sed -E "s/PEERTUBE_WEBSERVER_HOSTNAME=//g"`"

# Get admin email
PEERTUBE_ADMIN_EMAIL="`grep -E -o "^PEERTUBE_ADMIN_EMAIL=(.+)" .env | sed -E "s/PEERTUBE_ADMIN_EMAIL=//g"`"

#################
### FUNCTIONS ###
#################

# Test if a program is installed
has() {
  type "$1" > /dev/null 2>&1
}

postgres_down() {
  # Stop and remove PostgreSQL container
  $COMPOSE rm -f -s -v $PEERTUBE_DB_HOSTNAME
}

postgres_dump() {
  if [ -z $1 ]; then
    echo "Usage:	peertube postgres:dump /PATH/FILENAME.tar"
    exit 1
  fi

  # Do not restore if PostgreSQL container is down
  if [ -z "$($COMPOSE ps -q $PEERTUBE_DB_HOSTNAME)" ]; then
    echo "$ERROR: PostgreSQL docker container is down, can't dump. First, you must run `peertube postgres:up`"
    exit 1
  fi

  # Dump PostgreSQL database
  $COMPOSE exec -T $PEERTUBE_DB_HOSTNAME pg_dump -U $POSTGRES_USER -Ft $POSTGRES_DB > $1
}

postgres_restore() {
  if [ -z $1 ]; then
    echo "Usage:	peertube postgres:restore /PATH/FILENAME.tar"
    exit 1
  fi

  missing_prerequisites=0

  if [ ! -f "$1" ]; then
    echo "$ERROR: Database dump archive `$1` not found, can't restore."
    missing_prerequisites=1
  fi

  # Do not restore if PostgreSQL container is down
  if [ -z "$($COMPOSE ps -q $PEERTUBE_DB_HOSTNAME)" ]; then
    echo "$ERROR: PostgreSQL docker container is down, can't restore. First, you must run `peertube postgres:up`"
    missing_prerequisites=1
  fi

  # Exit if not all prerequisites
  if [ "$missing_prerequisites" -ne 0 ]; then exit 1; fi

  # Run restore command
  $COMPOSE exec -T $PEERTUBE_DB_HOSTNAME pg_restore -U $POSTGRES_USER -d $POSTGRES_DB < $1
}

postgres_up() {
  $COMPOSE up -d $PEERTUBE_DB_HOSTNAME

  # Block stdout until database is up
  sleep 10s &
  while [ -z "`$COMPOSE logs --tail=2 $PEERTUBE_DB_HOSTNAME | grep -o 'database system is ready to accept connections'`" ]; do
    # Break if any database errors occur
    # Displays errors and exit
    db_errors=`$COMPOSE logs --tail=40 $PEERTUBE_DB_HOSTNAME | grep -i 'error'`
    if [ ! -z "$db_errors" ]; then
      echo $db_errors
      exit 1
    fi
    # Break after 10s / until pid of "sleep 10s" is destroyed
    # Display logs and exit
    if [ -z "`ps -ef | grep $! | grep -o -E 'sleep 10s'`" ]; then
      $COMPOSE logs --tail=40 $PEERTUBE_DB_HOSTNAME
      exit 1
    fi
  done
}

stack_up() {
   # Run compose detached and exit if any errors
  compose_errors=`$($COMPOSE up -d) | grep -i 'ERROR'`
  if [ ! -z "$compose_errors" ]; then
    exit 1
  fi

  # Block stdout until server is up
  sleep 50s &
  while [ -z "`$COMPOSE logs --tail=2 peertube | grep -o 'Server listening on'`" ]; do
    # Break if any stack errors occur
    # Displays errors and exit
    stack_errors=`$COMPOSE logs --tail=40 peertube | grep -i 'error'`
    if [ ! -z "$stack_errors" ]; then
      echo $stack_errors
      exit 1
    fi
    # Break after 50s / until pid of "sleep 50s" is destroyed
    # Display logs and exit
    if [ -z "`ps -ef | grep $! | grep -o -E 'sleep 50s'`" ]; then
      $COMPOSE logs --tail=40 peertube
      exit 1
    fi
  done
}

stack_down() {
  $COMPOSE down -v --remove-orphans
}

generate_ssl_certificate() {
<<<<<<< HEAD
  echo "Generate new SSL/TLS certificate using Let's Encrypt #"
=======
>>>>>>> 7eed02d... Put SSL certificate message into script
  docker run -it --rm \
  --name certbot \
  -p 80:80 \
  -v "$(pwd)/docker-volume/certbot/conf:/etc/letsencrypt" \
  certbot/certbot certonly \
  --standalone \
  --domain $PEERTUBE_WEBSERVER_HOSTNAME \
  --email $PEERTUBE_ADMIN_EMAIL \
  --no-eff-email \
  --agree-tos \
  --non-interactive
}

if [ "$1" = "purge-old-account" ]; then

  username=$2
  if [ -z "$username" ]; then
    echo "\nUsage:	peertube purge-old-account USERNAME\n"
    exit 1
  fi

  count=`$COMPOSE exec -T $PEERTUBE_DB_HOSTNAME psql -t -U $POSTGRES_USER $POSTGRES_DB -c "SELECT count(*) FROM account WHERE name = '$username';" | xargs`
  if [ "$count" -gt 0 ]; then
    echo "$ERROR: can't purge an existing account"
    exit 1
  fi

  # Run psql delete command
  channelname=$username"_channel"
  $COMPOSE exec -T $PEERTUBE_DB_HOSTNAME psql -e -U $POSTGRES_USER $POSTGRES_DB -c "DELETE FROM actor WHERE \"preferredUsername\" = '$username';"
  $COMPOSE exec -T $PEERTUBE_DB_HOSTNAME psql -e -U $POSTGRES_USER $POSTGRES_DB -c "DELETE FROM actor WHERE \"preferredUsername\" = '$channelname';"

elif [ "$1" = "psql" ]; then

  # Run psql command
  $COMPOSE exec -T $PEERTUBE_DB_HOSTNAME psql -U $POSTGRES_USER $POSTGRES_DB -c "$2"

elif [ "$1" = "postgres:down" ]; then

  posgres_down

elif [ "$1" = "postgres:dump" ]; then

  postgres_dump $2

elif [ "$1" = "postgres:restore" ]; then

  posgres_restore $2

elif [ "$1" = "postgres:up" ]; then

  posgres_up

elif [ "$1" = "up" ]; then

  stack_up

elif [ "$1" = "down" ]; then

  stack_down

elif [ "$1" = "upgrade" ]; then

  # root
  uid=`id -u`
  if [ "$uid" -ne 0 ]; then
    echo "$ERROR: this script must be run as root or as a sudoer user with sudo"
    exit 1
  fi

  echo "\n"
  echo "${ORANGE}WARNING BEFORE ANY UPGRADE${NC}:"
  echo "- Don't forget to backup $WORKDIR"
  echo "- Be sure to edit/merge any new configuration files"
  echo "  See breaking changes here: https://github.com/Chocobozzz/PeerTube/releases"
  echo "\n"
  echo "This script will automatically:"
  echo "- update docker-commpose and current CLI"
  echo "- down docker stack"
  echo "- export the database"
  echo "- pull latest images"
  echo "- re-import database"
  echo "- re-generate SSL certificates"
  echo "- re-up docker stack"
  echo "\n"

  read -p "Continue (y/N)?" CONT

  if [ "$CONT" = "y" ]; then
    # Upgrade docker-compose and current CLI
    echo "Upgrade docker-compose and current CLI #"
    sh -c "$(curl -f#L $PEERTUBE_DOCKER_RAW_URL/script/index.sh)" >&2

    # PeerTube Archive Dump for upgrade
    DB_DUMP=/tmp/peertube-db-dump.tar

    # Down all containers to not conflict upgrade
    echo "Down all containers to not conflict upgrade #"
    stack_down

    # Dump existing database to easier migrate if any PostgreSQL version upgrade
    # Re-Up PostgreSQL container
    echo "Re-Up PostgreSQL only #"
    postgres_up

    # Dump existing database
    echo "Dump PostgreSQL to easier migrate #"
    postgres_dump $DB_DUMP

    # Re-init existing database
    # Remove db files
    echo -n "Remove PosgreSQL mounted volume ..."
    rm -rf ./docker-volume/db
    echo $DONE

    # Up postgres service
    echo "Up PostgreSQL to restore dump #"
    postgres_up

    # Run restore command
    echo "Restore PostgreSQL dump #"
    postgres_restore $DB_DUMP

    # Clean database archive dump
    echo -n "Clean PostgreSQL dump ..."
    rm -f $DB_DUMP
    echo $DONE

    # Re-generate SSL/TLS certificate using Let's Encrypt
    echo "Re-generate SSL/TLS certificate #"
    generate_ssl_certificate

    # Re-start stack
    echo "Re-up all containers #"
    stack_up
  fi

elif [ "$1" = "show-dkim" ]; then

  cat ./docker-volume/opendkim/keys/*/*.txt

elif [ "$1" = "show-admin" ]; then

  username=`$COMPOSE logs peertube | grep -A1 -E -o "Username: [0-9a-zAZ-Z]*"`
  password=`$COMPOSE logs peertube | grep -A1 -E -o "User password: [0-9a-zAZ-Z]*"`

  if [ ! -z "$username" ] && [ ! -z "$password" ]; then
    echo $username
    echo $password
  else # If credentials are not found in compose logs
    if [ ! -f docker-volume/data/logs/peertube.log ]; then
      echo "$ERROR: Can't display Admin Credentials, missing docker-volume/data/logs/peertube.log"
      exit 1
    else
      username=`cat docker-volume/data/logs/peertube.log | grep -A1 -E -o "Username: [0-9a-zAZ-Z]*"`
      password=`cat docker-volume/data/logs/peertube.log | grep -A1 -E -o "User password: [0-9a-zAZ-Z]*"`

      if [ ! -z "$username" ] && [ ! -z "$password" ]; then
        echo $username
        echo $password
      else
        echo "$ERROR: Missing Admin Credentials in logs"
        exit 1
      fi
    fi
  fi

elif [ "$1" = "generate-ssl-certificate" ]; then

  generate_ssl_certificate

else

  # Run ServerTools command
  $COMPOSE exec -u peertube -e NODE_CONFIG_DIR=/config -e NODE_ENV=production peertube npm run $@

fi
